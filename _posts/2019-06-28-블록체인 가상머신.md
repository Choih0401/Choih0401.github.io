---


---

<h1 id="이더리움-가상-머신">이더리움 가상 머신</h1>
<h3 id="소개">소개</h3>
<ul>
<li>Ethereum 가상머신 즉 EVM은 Ethereum 스마트 컨트랙트를 위한 런타임 환경이다.</li>
<li>이것은 완전히 독립되어 있기 때문에 다른 프로세스 등에 접근할 수 없다.
<ul>
<li>심지어 스마트 컨트랙트는 다른 스마트컨트랙트에 접근이 제한적으로 불가능하다.</li>
</ul>
</li>
</ul>
<h3 id="계정">계정</h3>
<ul>
<li>Ethereum  내에는 같은 공간을 공유하는 2개의 계정이 있다.
<ul>
<li><strong>외부계정</strong>은 사람이 가지고 있는 비밀키, 비밀키 쌍으로 동작되며, <strong>컨트랙트 계정</strong>은 계정과 함께 저장된 코드에 의해 동작된다.</li>
</ul>
</li>
<li>일단 계정이 코드를 저장하든 아니든 상관없이 두 종류는 모두 EVM 내에서 동일하게 다뤄진다.</li>
<li>모든 계정들은 256비트의 문자열이 서로 키-</li>
<li>값으로 영구히 매핑된 <strong>스토리지</strong>를 가지고 있다.</li>
</ul>
<h3 id="트랜잭션">트랜잭션</h3>
<ul>
<li>트랜잭션은 한 계정에서 다른 계정으로 보내지는 일종의 메시지이다.</li>
<li>대상 계정이 코드를 포함하고 있다면 코드는 실행되고, 페이로드는 입력데이터로 제공된다.</li>
<li>대상 계정이 설정되지 않은 경우 트랜잭션은 새로운 컨트랙트를 생성하며 사용자와 "논스"라는 트랜잭션의 수에 의해 주소가 결정된다.
<blockquote>
<p>컨트랙트가 실행되는 동안, 컨트랙트의 코드는 비어 있는데 이 때문에 생성자가 실행을 끝낼 때까지 컨트랙트를 다시 호출해서는 안된다.</p>
</blockquote>
</li>
</ul>
<h3 id="가스">가스</h3>
<ul>
<li>트랜잭션 발생시 일정 양의 가스가 동시에 사용되며 이는 트랜잭션에 필요한 작업의 양을 제한한다는 목적을 가지고 있다.</li>
<li>그리고 특별한 규칙에 의해 작업중 가스는 조금씩 고갈되게 된다.</li>
<li>가스 가격은 트랜잭션을 만든 사용자가 정하게 된다.
<blockquote>
<p>사용자는 최대 가스 가격 * 가스 양을 지불합니다.<br>
실행이 끝난 이후에도 가스가 남았다면 같은 방식으로 사용자에게 환불된다.</p>
</blockquote>
</li>
</ul>
<h3 id="스토리지-메모리와-스택">스토리지, 메모리와 스택</h3>
<ul>
<li>스토리지
<ul>
<li>스토리지는 함수 호출과 트랜잭션 사이에서 영구적으로 존재한다.</li>
<li>컨트랙트 내의 스토리지를 읽고 수정하는데에는 많은 비용이 듭니다.</li>
</ul>
</li>
<li>메모리
<ul>
<li>각 메시지 콜에 대해 초기화 된 인스턴스</li>
<li>메모리는 선형이며 바이트 레벨 단위로 나눠진다.</li>
<li>메모리가 커질 수록 비용도 커지며 메모리가 확장되는 시점에 가스가 소모된다.</li>
</ul>
</li>
<li>스택
<ul>
<li>EVM은 레지스터 머신이 아니라 스택머신이다.</li>
<li>최대 1024개의 요소를 가질 수 있고, 256비트의 단어들을 포함한다.</li>
</ul>
</li>
</ul>
<h3 id="메시지-콜">메시지 콜</h3>
<ul>
<li>메시지 콜을 사용하면 다른 컨트랙트를 호출하거나 컨트랙트가 아닌 계정으로 Ether을 호출 할 수 있다.</li>
<li>호출은 1024개의 깊이로 제한되며 이는 <strong>복잡한 연산일 수록 재귀보다 반복문을 선호한다는 것을 뜻한다.</strong></li>
</ul>
<h3 id="델리게이트-콜">델리게이트 콜</h3>
<ul>
<li>대상 주소가 호출하는 컨트랙트의 컨트랙트 내에서 실행된다.</li>
<li>msg.sender와 msg.value 가 값이 바뀌지 않는다는 것 외에는 메시지 콜과 동일하다.</li>
</ul>
<h3 id="생성">생성</h3>
<ul>
<li>컨트랙트들은 특별한 연산부호를 사용하여 다른 컨트랙트들을 생성한다.</li>
</ul>
<h3 id="비활성화와-자기-소멸">비활성화와 자기 소멸</h3>
<ul>
<li>코드가 블록체인 안에서 지워지는 유일한 방법은 selfdestruct 연산을 사용할 때이다.
<ul>
<li>주소에 저장된 남은 Ether은 지정된 타겟으로 옮겨지고, 스토리지와 코드는 해당 상태에서 지워진다.</li>
<li><strong>만일 누군가가 제거된 컨트랙트에 Ether를 전송하면 해당 Ether은 영구적으로 손실되게 된다.</strong>
<blockquote>
<p>컨트랙트 코드가 selfdestruct를 포함하지 않더라고 delegatecall이나 callcode를 실행해 작업을 실행할 수 있다</p>
</blockquote>
</li>
</ul>
</li>
</ul>

